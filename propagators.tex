\documentclass[UKenglish,usenames,dvipsnames,svgnames,table,aspectratio=169,mathserif]{beamer}

\mode<presentation> {

%\usetheme{default}
\usetheme{Madrid}

\setbeamertemplate{footline} % To remove the footer line in all slides uncomment this line

\setbeamertemplate{navigation symbols}{} % To remove the navigation symbols from the bottom of all slides uncomment this line
}

\usepackage{graphicx} % Allows including images
\usepackage{booktabs} % Allows the use of \toprule, \midrule and \bottomrule in tables
\usepackage{hyperref}
%\usepackage{apacite}
\usepackage{babel}
\usepackage{fancyvrb}
\usepackage{color}
\usepackage{alltt}
\usepackage{listings}
\usepackage{framed}
\usepackage{courier}
\usepackage{minted}
\usepackage{epstopdf}
\usepackage{xifthen}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{textcomp}
\usepackage{gensymb}
\usepackage{svg}
\usepackage{pdfpages}
\usepackage{isodate}
\usepackage{Haskelllogo}

\hypersetup{colorlinks=false}

\setbeamertemplate{bibliography entry title}{}
\setbeamertemplate{bibliography entry location}{}
\setbeamertemplate{bibliography entry note}{}
\setbeamertemplate{itemize items}[circle]
\setbeamertemplate{enumerate items}[circle]
\beamertemplatenavigationsymbolsempty
\setbeamertemplate{footline}{}


\newminted{haskell}{}

\definecolor{g}{RGB}{0,100,0}
\newcommand{\highlight}[1]{\colorbox{yellow}{#1}}
\newcommand{\nega}[1]{\colorbox{yellow}{#1}}
\newcommand{\posi}[1]{\colorbox{green}{#1}}
\newcommand{\nl}{\vspace{\baselineskip}}
\newcommand{\pnl}{\pause \nl}

\graphicspath{{diagrams/}}

\newcommand{\textslide}[1]{{
\begin{frame}
\begin{center}

#1

\end{center}
\end{frame}
}}

\newcommand{\textslideleft}[1]{{
\begin{frame}

#1

\end{frame}
}}

\newcommand{\codeslide}[1]{{
\begin{frame}[fragile]
\begin{haskellcode}
#1
\end{haskellcode}
\end{frame}
}}


\newcommand{\imageslide}[2][1]{{
\begin{frame}\begin{center}
\includegraphics[scale=#1]{#2}
\end{center}\end{frame}
}}

\newcommand{\imageslideleft}[2][1]{{
\begin{frame}
\includegraphics[scale=#1]{#2}
\end{frame}
}}

\newcommand{\imagetextslide}[3][1]{{
\begin{frame}\begin{center}

{#3}

\includegraphics[scale=#1]{#2}
\end{center}\end{frame}
}}

\newcommand{\svgslide}[1]{{
\begin{frame}
\begin{center}
\includesvg{diagrams/#1}
\end{center}
\end{frame}
}}

\definecolor{bgc}{RGB}{255, 255, 255}
\setbeamercolor{background canvas}{bg=bgc}


%%----------------------------------------------------------------------------------------
%	TITLE PAGE
%----------------------------------------------------------------------------------------

\title[Propagators]{An Intuition for Propagators}
\titlegraphic{\includegraphics[scale=0.25]{data61.png}}
\author{George Wilson}
\institute[]
{
CSIRO's Data61\\
\medskip
\href{george.wilson@data61.csiro.au}{george.wilson@data61.csiro.au}
}

\selectlanguage{UKenglish}
\date{\printdate{2019-09-02}}

\begin{document}

%%%%%
%%%%% Intro section
%%%%%

\begin{frame}
\titlepage
\end{frame}


\begin{frame}

\huge \centering 1970s, MIT
\end{frame}


\begin{frame}

\Large \centering
a model of computation for {\bf highly concurrent} machines
\end{frame}


\imageslide[1.8]{intro-cell0.pdf}
\imageslide[1.8]{intro-cell1.pdf}
\imageslide[1.8]{intro-cell2.pdf}

\imageslide[1.5]{intro-prop0.pdf}
\imageslide[1.5]{intro-prop1.pdf}
\imageslide[1.5]{intro-prop2.pdf}
\imageslide[1.5]{intro-prop3.pdf}
\imageslide[1.5]{intro-prop4.pdf}
\imageslide[1.5]{intro-prop5.pdf}
\imageslide[1.5]{intro-prop6.pdf}


\begin{frame}[fragile]
\begin{haskellcode}
-- types
data Cell a

data Par a
instance Monad Par
\end{haskellcode}
\pnl
\begin{haskellcode}
-- Creating a cell
cell    :: Par (Cell a)
\end{haskellcode}
\pnl
\begin{haskellcode}
-- Working with Cells
content :: Cell a -> Par (Maybe a)
write   :: Cell a -> a -> Par ()
\end{haskellcode}
\pnl
\begin{haskellcode}
-- Creating a propagator
watch   :: Cell a -> (a -> Par ()) -> Par ()
\end{haskellcode}
\end{frame}


\begin{frame}[fragile]
\centering

\begin{columns}
\begin{column}{0.5\textwidth}
\begin{overlayarea}{0.5\textwidth}{0.4\textheight}
\begin{onlyenv}<1>
\includegraphics[scale=0.8]{intro-toUpper0.pdf}
\end{onlyenv}
\begin{onlyenv}<2>
\includegraphics[scale=0.8]{intro-toUpper1.pdf}
\end{onlyenv}
\begin{onlyenv}<3>
\includegraphics[scale=0.8]{intro-toUpper2.pdf}
\end{onlyenv}
\begin{onlyenv}<4>
\includegraphics[scale=0.8]{intro-toUpper3.pdf}
\end{onlyenv}
\begin{onlyenv}<5->
\includegraphics[scale=0.8]{intro-toUpper4.pdf}
\end{onlyenv}
\end{overlayarea}
\end{column}
\begin{column}{0.5\textwidth}
\begin{overlayarea}{\textwidth}{0.5\textheight}
\begin{onlyenv}<1->
\begin{haskellcode}
do
  input  <- cell
\end{haskellcode}
\end{onlyenv}
\begin{onlyenv}<2->
\begin{haskellcode}
  output <- cell
\end{haskellcode}
\end{onlyenv}
\begin{onlyenv}<3-5>
\begin{minted}{haskell}
  watch input (\c ->
    write output (toUpper c))
\end{minted}
\end{onlyenv}
\begin{onlyenv}<6>
\begin{minted}[highlightlines={1,2}]{haskell}
  watch input (\c ->
    write output (toUpper c))
\end{minted}
\end{onlyenv}

\nl
\begin{onlyenv}<4->
\begin{haskellcode}
  write input 'q'
  content output   -- Just 'Q'
\end{haskellcode}
\end{onlyenv}
\end{overlayarea}
\end{column}
\end{columns}
\end{frame}


\begin{frame}[fragile]
\begin{haskellcode}
          lift :: (a -> b) -> Cell a -> Cell b -> Par ()
          lift f input output =
            watch input (\a ->
              write output (f a))
\end{haskellcode}
\end{frame}


\begin{frame}[fragile]
\centering

\begin{columns}
\begin{column}{0.5\textwidth}
\begin{overlayarea}{0.5\textwidth}{0.4\textheight}
\includegraphics[scale=0.8]{intro-toUpper4.pdf}
\end{overlayarea}
\end{column}
\begin{column}{0.5\textwidth}
\begin{haskellcode}
do
  input  <- cell
\end{haskellcode}
\begin{haskellcode}
  output <- cell
\end{haskellcode}
\begin{minted}[highlightlines=1]{haskell}
  lift toUpper input output
\end{minted}
\nl
\begin{haskellcode}
  write input 'q'
  content output   -- Just 'Q'
\end{haskellcode}
\end{column}
\end{columns}

\end{frame}


\begin{frame}[fragile]
\centering


\begin{columns}
\begin{column}{0.5\textwidth}
\begin{overlayarea}{0.5\textwidth}{0.4\textheight}
\begin{onlyenv}<1>
\includegraphics[scale=0.9]{build-adder0.pdf}
\end{onlyenv}
\begin{onlyenv}<2->
\includegraphics[scale=0.9]{build-adder1.pdf}
\end{onlyenv}
\end{overlayarea}
\end{column}
\begin{column}{0.5\textwidth}
\begin{haskellcode}
do
  inL  <- cell
  inR  <- cell
  out  <- cell
\end{haskellcode}
\pnl
\begin{haskellcode}
  watch inL (\x -> do
    maybeY <- content inR
    case maybeY of
      Nothing -> pure ()
      Just y  -> write out (x+y)
\end{haskellcode}
\pnl
\begin{haskellcode}
  watch inR (\y -> do
    maybeX <- content inL
    case maybeX of
      Nothing -> pure ()
      Just x  -> write out (x+y)
\end{haskellcode}
\end{column}
\end{columns}
\end{frame}


\begin{frame}[fragile]
\begin{haskellcode}
          with :: Cell a -> (a -> Par ()) -> Par ()
          with theCell callback = do
            maybeA <- content theCell
              case maybeA of
                Nothing -> pure ()
                Just a  -> callback a
\end{haskellcode}
\end{frame}


\begin{frame}[fragile]
\centering

\begin{columns}
\begin{column}{0.5\textwidth}
\begin{overlayarea}{0.5\textwidth}{0.4\textheight}
\includegraphics[scale=0.8]{build-adder1.pdf}
\end{overlayarea}
\end{column}
\begin{column}{0.5\textwidth}
\begin{haskellcode}
do
  inL  <- cell
  inR  <- cell
  out  <- cell
\end{haskellcode}
\nl
\begin{haskellcode}
  watch inL (\x ->
    with inR (\y ->
      write out (x+y)
\end{haskellcode}
\pnl
\begin{haskellcode}
  watch inR (\y ->
    with inL (\x ->
      write out (x+y)
\end{haskellcode}
\end{column}
\end{columns}
\end{frame}
% TODO make numbers jump around to demonstrate the watch problem


\begin{frame}[fragile]
\begin{haskellcode}
          lift2 :: (a -> b -> c)
                -> Cell a -> Cell b -> Cell c
                -> Par ()
\end{haskellcode}
\pause
\begin{haskellcode}
          lift2 f inL inR out = do
            watch inL (\a ->
              with inR (\b ->
                write out (f a b)))
            watch inR (\b ->
              with inL (\a ->
                write out (f a b)))
\end{haskellcode}

\end{frame}


\begin{frame}[fragile]
\centering

\begin{columns}
\begin{column}{0.5\textwidth}
\begin{overlayarea}{0.5\textwidth}{0.4\textheight}
\includegraphics[scale=0.8]{build-adder1.pdf}
\end{overlayarea}
\end{column}
\begin{column}{0.5\textwidth}
\begin{haskellcode}
do
  inL  <- cell
  inR  <- cell
  out  <- cell
\end{haskellcode}
\nl
\begin{haskellcode}
  adder inL inR out

    where
      adder l r o = do
        lift2 (+) l r o
        lift2 (-) o l r
        lift2 (-) o r l
\end{haskellcode}
\end{column}
\end{columns}
\end{frame}

\begin{frame}
\centering
\fontsize{60}{70}\selectfont $?!$

\end{frame}


\begin{frame}
\centering \huge

How can we fix this?
\end{frame}


\begin{frame}[fragile]
\begin{columns}
\column{0.1\textwidth}
\column{0.7\textwidth}
\begin{overlayarea}{\textwidth}{0.6\textheight}
\begin{haskellcode}
data WriteOnce a
  = None
  | Written a
  | TooMany
\end{haskellcode}

\nl

\begin{onlyenv}<1>
\begin{haskellcode}
write ::           a -> WriteOnce a -> WriteOnce a
write a w = case w of
  None      -> Written a
  Written b -> TooMany
  TooMany   -> TooMany
\end{haskellcode}
\end{onlyenv}

\begin{onlyenv}<2->
\begin{haskellcode}
write :: (Eq a) => a -> WriteOnce a -> WriteOnce a
write a w = case w of
  None      -> Written a
  Written b -> if a == b then Written b else TooMany
  TooMany   -> TooMany
\end{haskellcode}
\end{onlyenv}
\end{overlayarea}
\column{0.2\textwidth}
\end{columns}
\end{frame}


\begin{frame}[fragile]
\centering \huge
Accumulate information about a value
\nl

\large
\begin{overlayarea}{\textwidth}{0.5\textheight}
\begin{onlyenv}<2>

\begin{haskellcode}

data WriteOnce a

  -- I don't know anything
  = None

  -- I know the answer exactly
  | Written a

  -- I have heard contradictory answers!
  | TooMany
\end{haskellcode}
\end{onlyenv}
\begin{onlyenv}<3>
The accumulation must:

\begin{itemize}
\item tolerate {\bf reordering} of information
\item tolerate {\bf grouping} of information
\item ignore {\bf redencancy} of information
\end{itemize}
\end{onlyenv}
\end{overlayarea}
\end{frame}


\begin{frame}[fragile]
\centering \huge
Bounded join semilattice
\nl
\large

Identity: \\
$x \vee bottom = bottom = bottom \vee x$
\nl

Commutative: \\
$x \vee y = y \vee x$
\nl

Associative: \\
$x \vee (y \vee z) = (x \vee y) \vee z$
\nl

Idempotent: \\
$x \vee x = x$

\end{frame}


\begin{frame}[fragile]
\begin{haskellcode}
class SemiLattice a where
  (\/)   :: a -> a -> a
  bottom :: a

instance (Eq a) => SemiLattice (WriteOnce a) where
  None      \/ b           = b
  TooMany   \/ x           = TooMany
  Written a \/ None        = Written a
  Written a \/ Written b   = Written a
  Written a \/ TooMany     = TooMany
\end{haskellcode}
\end{frame}


\begin{frame}[fragile]
\begin{haskellcode}
instance (Ord a) => Semilattice (Set a) where
  p \/ q = Set.union p q
  bottom = Set.empty
\end{haskellcode}
\end{frame}


\begin{frame}

\centering \huge
Monotonicity
\nl

\Large

$ x \leq y \implies f(x) \leq f(y)$

\end{frame}

% TODO graphs of monotone


\begin{frame}
\huge \centering
Thanks for listening!
\end{frame}


\end{document}
